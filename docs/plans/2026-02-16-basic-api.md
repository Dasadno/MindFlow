# Basic API Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Реализовать рабочий REST API для CRUD агентов и статуса мира поверх существующего SQLite.

**Architecture:** `Handler` struct в `internal/api` получает `*storage.Repository` через конструктор. `storage.Repository` инкапсулирует `*sql.DB` и реализует все SQL-запросы. `mux.go` подключает реальные обработчики вместо заглушек. Модуль — `milk`, БД уже существует, миграции не нужны.

**Tech Stack:** Go 1.24, standard library `net/http`, `modernc.org/sqlite`, `github.com/google/uuid`

---

## Контекст кодовой базы

```
server/
├── cmd/server/
│   ├── main.go                      ← точка входа, нужно добавить инициализацию Repository
│   └── middleware/mux.go            ← регистрация маршрутов, нужно подключить Handler
├── data/db.go                       ← глобальный data.Db *sql.DB
├── internal/
│   ├── api/
│   │   ├── dto.go                   ← все DTO уже определены, не трогать
│   │   ├── middleware.go            ← APIError уже определён, не трогать
│   │   ├── handlers.go              ← только комментарии, добавить handler.go рядом
│   │   └── router.go                ← только комментарии, не трогать
│   ├── storage/
│   │   └── sqlite.go                ← типы определены, нужно добавить методы
│   └── agent/agent.go               ← AgentState, Personality, Goal — использовать для маппинга
```

**Таблицы SQLite (уже существуют):**
- `agents`: id, name, personality (JSON), mood_state (JSON nullable), goals (JSON nullable), state, is_active, created_at, last_active, snapshot (JSON nullable)
- `memories`: id, agent_id, type, content, emotional_tag, importance, access_count, last_accessed, related_agents, metadata, created_at
- `relationships`: id, agent1_id, agent2_id, type, strength, interaction_count, last_interaction, metadata
- `events`: id, topic, type, source, affected_agents, payload, status, tick, created_at
- `world_state`: key, value, updated_at

**Импортный путь модуля:** `milk/server/internal/...`

---

### Task 1: `storage.NewRepository` + `ListAgents`

**Files:**
- Modify: `server/internal/storage/sqlite.go`

**Step 1: Добавить конструктор и метод ListAgents**

Дописать в конец `server/internal/storage/sqlite.go`:

```go
import (
    "database/sql"
    "fmt"
    "time"
)

// NewRepository создаёт Repository поверх существующего *sql.DB.
func NewRepository(db *sql.DB) *Repository {
    return &Repository{DB: db}
}

// ListAgents возвращает страницу агентов и их общее количество.
// filter.Page начинается с 1. filter.Limit = 0 → 20 по умолчанию.
func (r *Repository) ListAgents(filter AgentFilter) ([]AgentRecord, int, error) {
    limit := filter.Limit
    if limit <= 0 {
        limit = 20
    }
    page := filter.Page
    if page <= 0 {
        page = 1
    }
    offset := (page - 1) * limit

    // Формируем WHERE
    where := "WHERE 1=1"
    args := []any{}
    if filter.IsActive != nil {
        where += " AND is_active = ?"
        args = append(args, *filter.IsActive)
    }
    if filter.State != "" {
        where += " AND state = ?"
        args = append(args, filter.State)
    }

    // Считаем total
    var total int
    row := r.DB.QueryRow(fmt.Sprintf("SELECT COUNT(*) FROM agents %s", where), args...)
    if err := row.Scan(&total); err != nil {
        return nil, 0, fmt.Errorf("ListAgents count: %w", err)
    }

    // Основной запрос
    query := fmt.Sprintf(
        `SELECT id, name, personality, mood_state, goals, state, is_active, created_at, last_active, snapshot
         FROM agents %s ORDER BY created_at DESC LIMIT ? OFFSET ?`,
        where,
    )
    args = append(args, limit, offset)

    rows, err := r.DB.Query(query, args...)
    if err != nil {
        return nil, 0, fmt.Errorf("ListAgents query: %w", err)
    }
    defer rows.Close()

    var agents []AgentRecord
    for rows.Next() {
        var a AgentRecord
        if err := rows.Scan(
            &a.ID, &a.Name, &a.Personality, &a.MoodState, &a.Goals,
            &a.State, &a.IsActive, &a.CreatedAt, &a.LastActive, &a.Snapshot,
        ); err != nil {
            return nil, 0, fmt.Errorf("ListAgents scan: %w", err)
        }
        agents = append(agents, a)
    }
    return agents, total, rows.Err()
}
```

**Step 2: Проверить компиляцию**

```bash
cd /home/dasadno/Documents/Einstein-IslandAI && go build ./server/...
```
Expected: без ошибок.

**Step 3: Commit**

```bash
cd /home/dasadno/Documents/Einstein-IslandAI
git add server/internal/storage/sqlite.go
git commit -m "feat(storage): add NewRepository and ListAgents"
```

---

### Task 2: `GetAgentByID`, `CreateAgent`, `DeactivateAgent`

**Files:**
- Modify: `server/internal/storage/sqlite.go`

**Step 1: Добавить методы**

Дописать в конец `server/internal/storage/sqlite.go`:

```go
// GetAgentByID возвращает агента по UUID. Если не найден — (nil, nil).
func (r *Repository) GetAgentByID(id string) (*AgentRecord, error) {
    query := `SELECT id, name, personality, mood_state, goals, state, is_active, created_at, last_active, snapshot
              FROM agents WHERE id = ?`
    row := r.DB.QueryRow(query, id)
    var a AgentRecord
    err := row.Scan(
        &a.ID, &a.Name, &a.Personality, &a.MoodState, &a.Goals,
        &a.State, &a.IsActive, &a.CreatedAt, &a.LastActive, &a.Snapshot,
    )
    if err == sql.ErrNoRows {
        return nil, nil
    }
    if err != nil {
        return nil, fmt.Errorf("GetAgentByID: %w", err)
    }
    return &a, nil
}

// CreateAgent вставляет нового агента. rec.ID должен быть заполнен (UUID).
func (r *Repository) CreateAgent(rec AgentRecord) error {
    query := `INSERT INTO agents (id, name, personality, state, is_active, created_at)
              VALUES (?, ?, ?, ?, ?, ?)`
    _, err := r.DB.Exec(query,
        rec.ID, rec.Name, rec.Personality,
        rec.State, rec.IsActive, rec.CreatedAt,
    )
    if err != nil {
        return fmt.Errorf("CreateAgent: %w", err)
    }
    return nil
}

// DeactivateAgent выполняет soft-delete: устанавливает is_active = false.
func (r *Repository) DeactivateAgent(id string) error {
    res, err := r.DB.Exec(`UPDATE agents SET is_active = false WHERE id = ?`, id)
    if err != nil {
        return fmt.Errorf("DeactivateAgent: %w", err)
    }
    n, _ := res.RowsAffected()
    if n == 0 {
        return fmt.Errorf("agent not found: %s", id)
    }
    return nil
}
```

**Step 2: Проверить компиляцию**

```bash
cd /home/dasadno/Documents/Einstein-IslandAI && go build ./server/...
```

**Step 3: Commit**

```bash
git add server/internal/storage/sqlite.go
git commit -m "feat(storage): add GetAgentByID, CreateAgent, DeactivateAgent"
```

---

### Task 3: Вспомогательные методы для статистики агента

**Files:**
- Modify: `server/internal/storage/sqlite.go`

**Step 1: Добавить методы статистики**

```go
// CountMemoriesByAgent возвращает количество воспоминаний агента.
func (r *Repository) CountMemoriesByAgent(agentID string) (int, error) {
    var count int
    err := r.DB.QueryRow(`SELECT COUNT(*) FROM memories WHERE agent_id = ?`, agentID).Scan(&count)
    if err != nil {
        return 0, fmt.Errorf("CountMemoriesByAgent: %w", err)
    }
    return count, nil
}

// CountRelationshipsByAgent возвращает количество связей агента.
func (r *Repository) CountRelationshipsByAgent(agentID string) (int, error) {
    var count int
    err := r.DB.QueryRow(
        `SELECT COUNT(*) FROM relationships WHERE agent1_id = ? OR agent2_id = ?`,
        agentID, agentID,
    ).Scan(&count)
    if err != nil {
        return 0, fmt.Errorf("CountRelationshipsByAgent: %w", err)
    }
    return count, nil
}

// CountInteractionsByAgent возвращает суммарное кол-во взаимодействий агента.
func (r *Repository) CountInteractionsByAgent(agentID string) (int, error) {
    var count int
    err := r.DB.QueryRow(
        `SELECT COALESCE(SUM(interaction_count), 0) FROM relationships
         WHERE agent1_id = ? OR agent2_id = ?`,
        agentID, agentID,
    ).Scan(&count)
    if err != nil {
        return 0, fmt.Errorf("CountInteractionsByAgent: %w", err)
    }
    return count, nil
}

// CountActiveAgents возвращает количество активных агентов.
func (r *Repository) CountActiveAgents() (int, error) {
    var count int
    err := r.DB.QueryRow(`SELECT COUNT(*) FROM agents WHERE is_active = true`).Scan(&count)
    return count, err
}

// CountTotalEvents возвращает общее количество событий.
func (r *Repository) CountTotalEvents() (int, error) {
    var count int
    err := r.DB.QueryRow(`SELECT COUNT(*) FROM events`).Scan(&count)
    return count, err
}

// GetWorldState читает key-value таблицу world_state.
func (r *Repository) GetWorldState() (map[string]string, error) {
    rows, err := r.DB.Query(`SELECT key, value FROM world_state`)
    if err != nil {
        return nil, fmt.Errorf("GetWorldState: %w", err)
    }
    defer rows.Close()
    state := make(map[string]string)
    for rows.Next() {
        var k, v string
        if err := rows.Scan(&k, &v); err != nil {
            return nil, err
        }
        state[k] = v
    }
    return state, rows.Err()
}
```

**Step 2: Компиляция**

```bash
cd /home/dasadno/Documents/Einstein-IslandAI && go build ./server/...
```

**Step 3: Commit**

```bash
git add server/internal/storage/sqlite.go
git commit -m "feat(storage): add stats and world state query methods"
```

---

### Task 4: Создать `internal/api/handler.go` и helpers

**Files:**
- Create: `server/internal/api/handler.go`
- Create: `server/internal/api/helpers.go`

**Step 1: Создать `handler.go`**

```go
// server/internal/api/handler.go
package api

import "milk/server/internal/storage"

// Handler — HTTP-обработчики с доступом к хранилищу.
type Handler struct {
    repo *storage.Repository
}

// NewHandler создаёт Handler с инъекцией зависимости Repository.
func NewHandler(repo *storage.Repository) *Handler {
    return &Handler{repo: repo}
}
```

**Step 2: Создать `helpers.go`**

```go
// server/internal/api/helpers.go
package api

import (
    "encoding/json"
    "net/http"
)

// writeJSON сериализует v в JSON и пишет в ResponseWriter.
func writeJSON(w http.ResponseWriter, status int, v any) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    json.NewEncoder(w).Encode(v)
}

// writeError пишет APIError в JSON.
func writeError(w http.ResponseWriter, status int, code, message string) {
    writeJSON(w, status, &APIError{Code: code, Message: message})
}
```

**Step 3: Компиляция**

```bash
cd /home/dasadno/Documents/Einstein-IslandAI && go build ./server/...
```

**Step 4: Commit**

```bash
git add server/internal/api/handler.go server/internal/api/helpers.go
git commit -m "feat(api): add Handler struct and JSON helpers"
```

---

### Task 5: Agent handlers (`ListAgents`, `GetAgent`)

**Files:**
- Create: `server/internal/api/agent_handlers.go`

**Step 1: Создать файл**

Нужно понимать маппинг: `AgentRecord` → `AgentSummary`/`AgentDetailResponse`.
- `personalityType` вычисляется из dominant Big Five черты (простое правило: если openness > 0.7 → "explorer", extraversion < 0.3 → "introvert", иначе "guardian")
- `currentMood` берётся из `mood_state` JSON-поля, или "neutral" если NULL
- `moodIntensity` — `|pleasure|` из PAD-вектора, или 0.5 по умолчанию

```go
// server/internal/api/agent_handlers.go
package api

import (
    "encoding/json"
    "net/http"
    "strconv"
    "time"

    "milk/server/internal/storage"
)

// ListAgents — GET /agents
// Query params: ?page=1&limit=20&active=true
func (h *Handler) ListAgents(w http.ResponseWriter, r *http.Request) {
    filter := storage.AgentFilter{
        Page:  parseIntQuery(r, "page", 1),
        Limit: parseIntQuery(r, "limit", 20),
    }

    // ?active=true → только активные
    if activeStr := r.URL.Query().Get("active"); activeStr != "" {
        v, err := strconv.ParseBool(activeStr)
        if err == nil {
            filter.IsActive = &v
        }
    }

    records, total, err := h.repo.ListAgents(filter)
    if err != nil {
        writeError(w, http.StatusInternalServerError, ErrCodeInternalError, "failed to list agents")
        return
    }

    summaries := make([]AgentSummary, 0, len(records))
    for _, rec := range records {
        summaries = append(summaries, recordToSummary(rec))
    }

    writeJSON(w, http.StatusOK, AgentListResponse{
        Agents: summaries,
        Pagination: PaginationMeta{
            Page:  filter.Page,
            Limit: filter.Limit,
            Total: total,
        },
    })
}

// GetAgent — GET /agents/{id}
func (h *Handler) GetAgent(w http.ResponseWriter, r *http.Request) {
    id := r.PathValue("id")
    if id == "" {
        writeError(w, http.StatusBadRequest, ErrCodeBadRequest, "missing agent id")
        return
    }

    rec, err := h.repo.GetAgentByID(id)
    if err != nil {
        writeError(w, http.StatusInternalServerError, ErrCodeInternalError, "failed to get agent")
        return
    }
    if rec == nil {
        writeError(w, http.StatusNotFound, ErrCodeNotFound, "agent not found")
        return
    }

    // Статистика
    memories, _ := h.repo.CountMemoriesByAgent(id)
    relations, _ := h.repo.CountRelationshipsByAgent(id)
    interactions, _ := h.repo.CountInteractionsByAgent(id)
    days := int(time.Since(rec.CreatedAt).Hours() / 24)

    // Personality из JSON
    personality := parsePersonality(rec.Personality)

    // Mood из JSON
    mood := parseMood(rec.MoodState.String)

    // Goals из JSON
    goals := parseGoals(rec.Goals.String)

    detail := AgentDetailResponse{
        ID:          rec.ID,
        Name:        rec.Name,
        Personality: personality,
        CurrentMood: mood,
        Goals:       goals,
        Stats: AgentStatsDTO{
            TotalInteractions:  interactions,
            MemoriesCount:      memories,
            RelationshipsCount: relations,
            DaysSinceCreation:  days,
        },
        CreatedAt: rec.CreatedAt,
    }
    writeJSON(w, http.StatusOK, detail)
}

// ── Вспомогательные функции ──────────────────────────────────────────────────

func recordToSummary(rec storage.AgentRecord) AgentSummary {
    mood, intensity := moodFromJSON(rec.MoodState.String)
    personality := parsePersonality(rec.Personality)
    return AgentSummary{
        ID:              rec.ID,
        Name:            rec.Name,
        PersonalityType: personalityType(personality),
        CurrentMood:     mood,
        MoodIntensity:   intensity,
        IsActive:        rec.IsActive,
    }
}

// personalityType вычисляет упрощённый тип из Big Five.
func personalityType(p PersonalityDTO) string {
    if p.Openness > 0.7 {
        return "explorer"
    }
    if p.Extraversion < 0.3 {
        return "introvert"
    }
    return "guardian"
}

// moodFromJSON разбирает PAD JSON и возвращает (label, intensity).
func moodFromJSON(moodJSON string) (string, float64) {
    if moodJSON == "" {
        return "neutral", 0.5
    }
    var pad struct {
        Label    string  `json:"label"`
        Pleasure float64 `json:"pleasure"`
    }
    if err := json.Unmarshal([]byte(moodJSON), &pad); err != nil {
        return "neutral", 0.5
    }
    label := pad.Label
    if label == "" {
        label = "neutral"
    }
    intensity := pad.Pleasure
    if intensity < 0 {
        intensity = -intensity
    }
    if intensity == 0 {
        intensity = 0.5
    }
    return label, intensity
}

func parsePersonality(raw string) PersonalityDTO {
    var p PersonalityDTO
    if raw == "" {
        return p
    }
    json.Unmarshal([]byte(raw), &p) //nolint:errcheck
    return p
}

func parseMood(raw string) MoodDTO {
    if raw == "" {
        return MoodDTO{Label: "neutral"}
    }
    var m MoodDTO
    json.Unmarshal([]byte(raw), &m) //nolint:errcheck
    if m.Label == "" {
        m.Label = "neutral"
    }
    return m
}

func parseGoals(raw string) []GoalDTO {
    if raw == "" {
        return []GoalDTO{}
    }
    var goals []GoalDTO
    json.Unmarshal([]byte(raw), &goals) //nolint:errcheck
    if goals == nil {
        return []GoalDTO{}
    }
    return goals
}

func parseIntQuery(r *http.Request, key string, def int) int {
    s := r.URL.Query().Get(key)
    if s == "" {
        return def
    }
    v, err := strconv.Atoi(s)
    if err != nil || v <= 0 {
        return def
    }
    return v
}
```

**Step 2: Компиляция**

```bash
cd /home/dasadno/Documents/Einstein-IslandAI && go build ./server/...
```

**Step 3: Commit**

```bash
git add server/internal/api/agent_handlers.go
git commit -m "feat(api): implement ListAgents and GetAgent handlers"
```

---

### Task 6: Handlers `SpawnAgent` и `DeactivateAgent`

**Files:**
- Create: `server/internal/api/control_handlers.go`

**Step 1: Создать файл**

```go
// server/internal/api/control_handlers.go
package api

import (
    "encoding/json"
    "net/http"
    "time"

    "github.com/google/uuid"
    "milk/server/internal/storage"
)

// SpawnAgent — POST /control/spawn
// Body: SpawnAgentRequest{Name, Personality}
func (h *Handler) SpawnAgent(w http.ResponseWriter, r *http.Request) {
    var req SpawnAgentRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        writeError(w, http.StatusBadRequest, ErrCodeBadRequest, "invalid JSON body")
        return
    }
    if req.Name == "" {
        writeError(w, http.StatusBadRequest, ErrCodeBadRequest, "name is required")
        return
    }

    personalityJSON, err := json.Marshal(req.Personality)
    if err != nil {
        writeError(w, http.StatusInternalServerError, ErrCodeInternalError, "failed to encode personality")
        return
    }

    rec := storage.AgentRecord{
        ID:          uuid.New().String(),
        Name:        req.Name,
        Personality: string(personalityJSON),
        State:       "idle",
        IsActive:    true,
        CreatedAt:   time.Now().UTC(),
    }

    if err := h.repo.CreateAgent(rec); err != nil {
        writeError(w, http.StatusInternalServerError, ErrCodeInternalError, "failed to create agent")
        return
    }

    writeJSON(w, http.StatusCreated, AgentDetailResponse{
        ID:          rec.ID,
        Name:        rec.Name,
        Personality: req.Personality,
        CurrentMood: MoodDTO{Label: "neutral"},
        Goals:       []GoalDTO{},
        CreatedAt:   rec.CreatedAt,
    })
}

// DeactivateAgentHandler — DELETE /control/agents/{id}
func (h *Handler) DeactivateAgentHandler(w http.ResponseWriter, r *http.Request) {
    id := r.PathValue("id")
    if id == "" {
        writeError(w, http.StatusBadRequest, ErrCodeBadRequest, "missing agent id")
        return
    }

    if err := h.repo.DeactivateAgent(id); err != nil {
        // DeactivateAgent возвращает "agent not found" если RowsAffected == 0
        writeError(w, http.StatusNotFound, ErrCodeNotFound, "agent not found")
        return
    }

    writeJSON(w, http.StatusOK, SuccessResponse{
        Success: true,
        Message: "agent deactivated",
    })
}
```

**Step 2: Компиляция**

```bash
cd /home/dasadno/Documents/Einstein-IslandAI && go build ./server/...
```

**Step 3: Commit**

```bash
git add server/internal/api/control_handlers.go
git commit -m "feat(api): implement SpawnAgent and DeactivateAgent handlers"
```

---

### Task 7: World status handler

**Files:**
- Create: `server/internal/api/world_handlers.go`

**Step 1: Создать файл**

```go
// server/internal/api/world_handlers.go
package api

import (
    "net/http"
    "strconv"
    "time"
)

// serverStartTime хранит время запуска для вычисления uptime.
var serverStartTime = time.Now()

// GetWorldStatus — GET /world/status
func (h *Handler) GetWorldStatus(w http.ResponseWriter, r *http.Request) {
    activeAgents, err := h.repo.CountActiveAgents()
    if err != nil {
        writeError(w, http.StatusInternalServerError, ErrCodeInternalError, "failed to count agents")
        return
    }

    totalEvents, err := h.repo.CountTotalEvents()
    if err != nil {
        writeError(w, http.StatusInternalServerError, ErrCodeInternalError, "failed to count events")
        return
    }

    // Читаем world_state из БД (tick, speed, paused)
    state, err := h.repo.GetWorldState()
    if err != nil {
        writeError(w, http.StatusInternalServerError, ErrCodeInternalError, "failed to get world state")
        return
    }

    currentTick, _ := strconv.ParseInt(state["current_tick"], 10, 64)
    simSpeed := 1.0
    if s, ok := state["simulation_speed"]; ok {
        if v, err := strconv.ParseFloat(s, 64); err == nil {
            simSpeed = v
        }
    }
    isPaused := state["is_paused"] == "true"

    uptime := formatUptime(time.Since(serverStartTime))

    writeJSON(w, http.StatusOK, WorldStatusResponse{
        CurrentTick:     currentTick,
        SimulationSpeed: simSpeed,
        IsPaused:        isPaused,
        ActiveAgents:    activeAgents,
        TotalEvents:     totalEvents,
        Uptime:          uptime,
    })
}

// formatUptime форматирует duration в человекочитаемую строку "2h15m30s".
func formatUptime(d time.Duration) string {
    h := int(d.Hours())
    m := int(d.Minutes()) % 60
    s := int(d.Seconds()) % 60
    if h > 0 {
        return strconv.Itoa(h) + "h" + strconv.Itoa(m) + "m" + strconv.Itoa(s) + "s"
    }
    if m > 0 {
        return strconv.Itoa(m) + "m" + strconv.Itoa(s) + "s"
    }
    return strconv.Itoa(s) + "s"
}
```

**Step 2: Компиляция**

```bash
cd /home/dasadno/Documents/Einstein-IslandAI && go build ./server/...
```

**Step 3: Commit**

```bash
git add server/internal/api/world_handlers.go
git commit -m "feat(api): implement GetWorldStatus handler"
```

---

### Task 8: Подключить Handler в `mux.go` и `main.go`

**Files:**
- Modify: `server/cmd/server/middleware/mux.go`
- Modify: `server/cmd/server/main.go`

**Step 1: Обновить `mux.go`**

Заменить сигнатуру `NewMux()` → `NewMux(h *api.Handler)` и подключить реальные обработчики.

```go
// server/cmd/server/middleware/mux.go
package middleware

import (
    "net/http"

    "milk/server/internal/api"
)

func TODO(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusOK)
    w.Write([]byte("endpoint in work"))
}

func NewMux(h *api.Handler) *http.ServeMux {
    mux := http.NewServeMux()

    // AGENTS
    mux.HandleFunc("GET /agents", h.ListAgents)
    mux.HandleFunc("GET /agents/{id}/memory", TODO)
    mux.HandleFunc("GET /agents/{id}/thoughts", TODO)
    mux.HandleFunc("GET /agents/{id}", h.GetAgent)
    mux.HandleFunc("POST /agents/{id}/inject", TODO)

    // RELATIONSHIPS
    mux.HandleFunc("GET /relationships", TODO)
    mux.HandleFunc("GET /relationships/{agentId}", TODO)
    mux.HandleFunc("POST /relationships", TODO)

    // EVENTS
    mux.HandleFunc("GET /events", TODO)
    mux.HandleFunc("POST /events", TODO)
    mux.HandleFunc("GET /events/stream", TODO)

    // WORLD
    mux.HandleFunc("GET /world/status", h.GetWorldStatus)
    mux.HandleFunc("POST  /world/control", TODO)
    mux.HandleFunc("GET /world/statistics", TODO)

    // CONTROL PANEL
    mux.HandleFunc("POST /control/spawn", h.SpawnAgent)
    mux.HandleFunc("DELETE /control/agents/{id}", h.DeactivateAgentHandler)
    mux.HandleFunc("POST /control/reset", TODO)

    return mux
}
```

**Step 2: Обновить `main.go`**

```go
// server/cmd/server/main.go
package main

import (
    "fmt"
    "net/http"

    "github.com/rs/cors"
    "milk/server/cmd/server/middleware"
    "milk/server/data"
    "milk/server/internal/api"
    "milk/server/internal/storage"
)

func main() {
    data.DbConnection()

    repo := storage.NewRepository(data.Db)
    handler := api.NewHandler(repo)

    mux := middleware.NewMux(handler)

    h := cors.New(cors.Options{
        AllowedOrigins: []string{"http://localhost:5173"},
        AllowedMethods: []string{"GET", "POST", "PATCH", "OPTIONS", "DELETE"},
        AllowedHeaders: []string{"Content-type"},
        Debug:          true,
    }).Handler(mux)

    fmt.Println("server starting on :8080")
    if err := http.ListenAndServe(":8080", h); err != nil {
        fmt.Println("failed to connect server: ", err)
    }
}
```

**Step 3: Компиляция**

```bash
cd /home/dasadno/Documents/Einstein-IslandAI && go build ./server/...
```

**Step 4: Commit**

```bash
git add server/cmd/server/middleware/mux.go server/cmd/server/main.go
git commit -m "feat: wire Handler into mux and main, basic API ready"
```

---

### Task 9: Smoke-test вручную

**Step 1: Запустить сервер**

```bash
cd /home/dasadno/Documents/Einstein-IslandAI
DB_PATH=server/data/society.db go run ./server/cmd/server/
```
Expected: `connected succesfully` + `server starting on :8080`

**Step 2: GET /world/status**

```bash
curl -s http://localhost:8080/world/status | python3 -m json.tool
```
Expected: JSON с `currentTick`, `isPaused`, `activeAgents`, `uptime`.

**Step 3: GET /agents**

```bash
curl -s http://localhost:8080/agents | python3 -m json.tool
```
Expected: `{"agents":[], "pagination":{"page":1,"limit":20,"total":0}}`

**Step 4: POST /control/spawn**

```bash
curl -s -X POST http://localhost:8080/control/spawn \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Alice",
    "personality": {
      "openness": 0.8,
      "conscientiousness": 0.6,
      "extraversion": 0.4,
      "agreeableness": 0.7,
      "neuroticism": 0.3,
      "coreValues": ["curiosity","honesty"],
      "quirks": ["talks to herself"]
    }
  }' | python3 -m json.tool
```
Expected: `201 Created` с UUID и именем "Alice".

**Step 5: GET /agents снова — должен вернуть Alice**

```bash
curl -s http://localhost:8080/agents | python3 -m json.tool
```
Expected: Alice в списке.

**Step 6: GET /agents/{id}**

```bash
AGENT_ID=$(curl -s http://localhost:8080/agents | python3 -c "import sys,json; print(json.load(sys.stdin)['agents'][0]['id'])")
curl -s http://localhost:8080/agents/$AGENT_ID | python3 -m json.tool
```
Expected: полный профиль с `personality`, `stats`, `goals`.

**Step 7: DELETE /control/agents/{id}**

```bash
curl -s -X DELETE http://localhost:8080/control/agents/$AGENT_ID | python3 -m json.tool
```
Expected: `{"success":true,"message":"agent deactivated"}`

**Step 8: Проверить деактивацию**

```bash
curl -s "http://localhost:8080/agents?active=true" | python3 -m json.tool
```
Expected: пустой список (агент деактивирован).

---

## Итого: что реализовано

| Маршрут | Метод | Статус |
|---------|-------|--------|
| `GET /agents` | ListAgents | ✅ |
| `GET /agents/{id}` | GetAgent | ✅ |
| `POST /control/spawn` | SpawnAgent | ✅ |
| `DELETE /control/agents/{id}` | DeactivateAgent | ✅ |
| `GET /world/status` | GetWorldStatus | ✅ |
| Остальные маршруты | TODO | заглушки |

## Файлы, созданные/изменённые

| Файл | Действие |
|------|----------|
| `server/internal/storage/sqlite.go` | добавлены методы |
| `server/internal/api/handler.go` | создан |
| `server/internal/api/helpers.go` | создан |
| `server/internal/api/agent_handlers.go` | создан |
| `server/internal/api/control_handlers.go` | создан |
| `server/internal/api/world_handlers.go` | создан |
| `server/cmd/server/middleware/mux.go` | обновлён |
| `server/cmd/server/main.go` | обновлён |
